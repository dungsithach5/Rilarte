const prisma = require('../lib/prisma');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { sendMail } = require('../utils/mailer');

// Validation helper functions
const validatePassword = (password) => {
  const passwordRegex = /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d@$!%*?&]{8,}$/;
  return passwordRegex.test(password);
};

const validateEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

// Bi·∫øn l∆∞u OTP t·∫°m th·ªùi (email -> { otp, expires })
const otpStore = {};

// API g·ª≠i OTP
exports.sendOtp = async (req, res) => {
  const { email } = req.body;
  if (!email) return res.status(400).json({ message: 'Email is required' });

  // T·∫°o OTP 4 s·ªë
  const otp = Math.floor(1000 + Math.random() * 9000).toString();
  // L∆∞u v√†o memory, h·∫øt h·∫°n sau 5 ph√∫t
  otpStore[email] = { otp, expires: Date.now() + 5 * 60 * 1000 };

  try {
    console.log(`üìß ƒêang g·ª≠i OTP ${otp} ƒë·∫øn email: ${email}`);
    
    await sendMail({
      to: email,
      subject: 'Your OTP Code',
      text: `Your OTP code is: ${otp}`,
      html: `<b>Your OTP code is: ${otp}</b>`
    });
    
    console.log(`‚úÖ OTP ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng ƒë·∫øn ${email}`);
    res.json({ message: 'OTP sent to email!' });
  } catch (err) {
    console.error(`‚ùå L·ªói g·ª≠i OTP ƒë·∫øn ${email}:`, err);
    
    // X√≥a OTP kh·ªèi store n·∫øu g·ª≠i th·∫•t b·∫°i
    delete otpStore[email];
    
    res.status(500).json({ 
      message: 'Failed to send OTP', 
      error: err.message,
      details: 'Please check your email configuration and try again'
    });
  }
};

// API x√°c th·ª±c OTP
exports.verifyOtp = (req, res) => {
  const { email, otp } = req.body;
  const record = otpStore[email];
  if (!record) return res.status(400).json({ message: 'No OTP sent to this email' });
  if (Date.now() > record.expires) return res.status(400).json({ message: 'OTP expired' });
  if (record.otp !== otp) return res.status(400).json({ message: 'Invalid OTP' });
  // X√°c th·ª±c th√†nh c√¥ng, x√≥a OTP
  delete otpStore[email];
  res.json({ message: 'OTP verified' });
};

exports.register = async (req, res) => {
  try {
    console.log('üìù Registration request received:', {
      body: req.body,
      headers: req.headers,
      method: req.method,
      url: req.url
    });

    const { username, email, password, confirmPassword } = req.body;
    console.log('üìù Registration data:', { username, email, hasPassword: !!password, hasConfirmPassword: !!confirmPassword });

    // Input validation
    if (!username || !email || !password || !confirmPassword) {
      console.log('‚ùå Validation failed - missing fields:', {
        hasUsername: !!username,
        hasEmail: !!email,
        hasPassword: !!password,
        hasConfirmPassword: !!confirmPassword
      });
      return res.status(400).json({ 
        success: false, 
        message: 'All fields are required' 
      });
    }

    // Email validation
    if (!validateEmail(email)) {
      console.log('‚ùå Email validation failed:', email);
      return res.status(400).json({ 
        success: false, 
        message: 'Please enter a valid email address' 
      });
    }

    // Password confirmation check
    if (password !== confirmPassword) {
      console.log('‚ùå Password confirmation failed:', {
        passwordLength: password?.length,
        confirmPasswordLength: confirmPassword?.length,
        passwordsMatch: password === confirmPassword
      });
      return res.status(400).json({ 
        success: false, 
        message: 'Passwords do not match' 
      });
    }

    // Password strength validation
    if (!validatePassword(password)) {
      console.log('‚ùå Password strength validation failed:', {
        passwordLength: password?.length,
        hasLetters: /[a-zA-Z]/.test(password),
        hasNumbers: /\d/.test(password)
      });
      return res.status(400).json({ 
        success: false, 
        message: 'Password must be at least 8 characters long and contain both letters and numbers' 
      });
    }

    // Check if email already exists
    console.log('üîç Checking if email already exists:', email);
    const existingUser = await prisma.users.findUnique({ where: { email } });
    if (existingUser) {
      console.log('‚ùå Email already exists:', email);
      return res.status(400).json({ 
        success: false, 
        message: 'Email already exists' 
      });
    }
    console.log('‚úÖ Email is available');

    // Check if username already exists
    console.log('üîç Checking if username already exists:', username);
    const existingUsername = await prisma.users.findUnique({ where: { username } });
    if (existingUsername) {
      console.log('‚ùå Username already exists:', username);
      return res.status(400).json({ 
        success: false, 
        message: 'Username already exists' 
      });
    }
    console.log('‚úÖ Username is available');

    // Hash password
    console.log('üîê Hashing password...');
    const saltRounds = 12;
    const hashedPassword = await bcrypt.hash(password, saltRounds);
    console.log('‚úÖ Password hashed successfully');

    // Create user
    console.log('üë§ Creating user in database...');
    const newUser = await prisma.users.create({
      data: {
        username,
        email,
        password: hashedPassword
      }
    });
    console.log('‚úÖ User created successfully:', {
      id: newUser.id,
      username: newUser.username,
      email: newUser.email
    });

    // Generate JWT token
    console.log('üîë Generating JWT token...');
    const jwtSecret = process.env.JWT_SECRET || 'your-secret-key';
    console.log('üîë JWT Secret available:', !!jwtSecret, 'Length:', jwtSecret?.length);
    
          const token = jwt.sign(
        { 
          id: Number(newUser.id), // Convert BigInt to Number
          email: newUser.email, 
          username: newUser.username 
        },
        jwtSecret,
        { expiresIn: '24h' }
      );
    console.log('‚úÖ JWT token generated successfully');

          // Return success response (without password)
      const userResponse = {
        id: Number(newUser.id), // Convert BigInt to Number
        username: newUser.username,
        email: newUser.email,
        bio: newUser.bio,
        avatar_url: newUser.avatar_url,
        createdAt: newUser.createdAt
      };

    console.log('üì§ Sending success response...');
    res.status(201).json({
      success: true,
      message: 'User registered successfully',
      token,
      user: userResponse
    });
    console.log('‚úÖ Registration completed successfully');

  } catch (error) {
    console.error('‚ùå Registration error:', error);
    
    // N·∫øu c√≥ response ƒë√£ ƒë∆∞·ª£c g·ª≠i, kh√¥ng g·ª≠i th√™m
    if (res.headersSent) {
      return;
    }
    
    // Log chi ti·∫øt l·ªói database
    if (error.code === 'P2002') {
      console.error('üîç Duplicate constraint error - Field:', error.meta?.target);
      return res.status(400).json({ 
        success: false, 
        message: 'Email ho·∫∑c username ƒë√£ t·ªìn t·∫°i trong h·ªá th·ªëng' 
      });
    } else if (error.code === 'P2003') {
      console.error('üîç Foreign key constraint error');
      return res.status(400).json({ 
        success: false, 
        message: 'D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá - L·ªói r√†ng bu·ªôc database' 
      });
    } else if (error.code === 'P2014') {
      console.error('üîç Invalid ID error');
      return res.status(400).json({ 
        success: false, 
        message: 'ID kh√¥ng h·ª£p l·ªá' 
      });
    } else if (error.code === 'P2025') {
      console.error('üîç Record not found error');
      return res.status(404).json({ 
        success: false, 
        message: 'Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu c·∫ßn thi·∫øt' 
      });
    } else if (error.message === 'Email already exists') {
      return res.status(400).json({ 
        success: false, 
        message: 'Email already exists' 
      });
    } else if (error.message === 'Username already exists') {
      return res.status(400).json({ 
        success: false, 
        message: 'Username already exists' 
      });
    } else {
      console.error('üîç Unknown error:', error.message);
      return res.status(500).json({ 
        success: false, 
        message: 'L·ªói server trong qu√° tr√¨nh ƒëƒÉng k√Ω. Vui l√≤ng th·ª≠ l·∫°i sau.',
        error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
      });
    }
  }
};

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;

    // Input validation
    if (!email || !password) {
      return res.status(400).json({ 
        success: false, 
        message: 'Email and password are required' 
      });
    }

    // Find user by email
    const user = await prisma.users.findUnique({ where: { email } });
    if (!user) {
      return res.status(401).json({ 
        success: false, 
        message: 'Invalid email or password' 
      });
    }

    // Verify password
    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      return res.status(401).json({ 
        success: false, 
        message: 'Invalid email or password' 
      });
    }

    // Generate JWT token
    const token = jwt.sign(
      { 
        id: Number(user.id), // Convert BigInt to Number
        email: user.email, 
        username: user.username 
      },
      process.env.JWT_SECRET || 'your-secret-key',
      { expiresIn: '24h' }
    );

    // Return success response (without password)
    const userResponse = {
      id: Number(user.id), // Convert BigInt to Number
      username: user.username,
      email: user.email,
      bio: user.bio,
      avatar_url: user.avatar_url,
      createdAt: user.createdAt
    };

    res.status(200).json({
      success: true,
      message: 'Login successful',
      token,
      user: userResponse
    });

  } catch (error) {
    console.error('‚ùå Login error:', error);
    
    // Log chi ti·∫øt l·ªói
    if (error.code === 'P2002') {
      console.error('üîç Duplicate constraint error - Field:', error.meta?.target);
      res.status(400).json({ 
        success: false, 
        message: 'D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá - L·ªói r√†ng bu·ªôc database' 
      });
    } else if (error.code === 'P2003') {
      console.error('üîç Foreign key constraint error');
      res.status(400).json({ 
        success: false, 
        message: 'D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá - L·ªói r√†ng bu·ªôc database' 
      });
    } else if (error.code === 'P2014') {
      console.error('üîç Invalid ID error');
      res.status(400).json({ 
        success: false, 
        message: 'ID kh√¥ng h·ª£p l·ªá' 
      });
    } else if (error.code === 'P2025') {
      console.error('üîç Record not found error');
      res.status(404).json({ 
        success: false, 
        message: 'Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu c·∫ßn thi·∫øt' 
      });
    } else {
      console.error('üîç Unknown database error:', error.code, error.message);
      res.status(500).json({ 
        success: false, 
        message: 'L·ªói server trong qu√° tr√¨nh ƒëƒÉng nh·∫≠p. Vui l√≤ng th·ª≠ l·∫°i sau.',
        error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
      });
    }
  }
};

exports.searchUsers = async (req, res) => {
  try {
    const { keyword } = req.query;
    if (!keyword) return res.status(400).json({ success: false, users: [], message: 'Keyword is required' });

    const users = await prisma.users.findMany({
      where: {
        OR: [
          { username: { contains: keyword } },
        ]
      },
      select: {
        id: true,
        username: true,
        avatar_url: true
      },
      take: 10
    });

    res.status(200).json(users);
  } catch (error) {
    console.error('Search users error:', error);
    res.status(500).json({ success: false, users: [], message: 'Error searching users' });
  }
};

exports.getAllUsers = async (req, res) => {
  try {
    const users = await prisma.users.findMany({
      select: {
        id: true,
        username: true,
        email: true,
        bio: true,
        avatar_url: true,
        createdAt: true
      }
    });
    res.status(200).json({
      success: true,
      users
    });
  } catch (error) {
    console.error('Get users error:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Error fetching users' 
    });
  }
};

// Get user by ID (public info only)
exports.getUserById = async (req, res) => {
    try {
        const userId = Number(req.params.id);
        
        const user = await prisma.users.findUnique({
            where: { id: userId },
            select: {
                id: true,
                username: true,
                avatar_url: true
            }
        });

        if (!user) {
            return res.status(404).json({ 
                success: false, 
                message: 'User not found' 
            });
        }

        res.status(200).json({
            success: true,
            user: {
                id: Number(user.id), // Convert BigInt to Number
                username: user.username,
                avatar: user.avatar_url || '/img/user.png',
                name: user.username
            }
        });
    } catch (error) {
        console.error('Error getting user by ID:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error getting user information' 
        });
    }
};

exports.updateUser = async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = { ...req.body };
    
    // Remove password from update data if present
    delete updateData.password;
    
    const updatedUser = await prisma.users.update({
      where: { id: Number(id) },
      data: updateData
    });
    
    res.status(200).json({
      success: true,
      message: 'User updated successfully',
      user: {
        ...updatedUser,
        id: Number(updatedUser.id) // Convert BigInt to Number
      }
    });
  } catch (error) {
    console.error('Update user error:', error);
    res.status(400).json({ 
      success: false, 
      message: 'Error updating user' 
    });
  }
};

exports.deleteUser = async (req, res) => {
  try {
    const deletedUser = await prisma.users.delete({
      where: { id: Number(req.params.id) }
    });

    if (!deletedUser) {
      return res.status(404).json({ 
        success: false, 
        message: 'User not found' 
      });
    }

    res.status(200).json({ 
      success: true, 
      message: 'User deleted successfully' 
    });
  } catch (error) {
    console.error('Delete user error:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Error deleting user' 
    });
  }
};

exports.resetPassword = async (req, res) => {
  console.log('RESET PASSWORD API CALLED', req.body);
  const { email, password, confirmPassword } = req.body;
  
  if (!email || !password || !confirmPassword) {
    return res.status(400).json({ message: 'Missing required fields' });
  }
  
  if (password !== confirmPassword) {
    return res.status(400).json({ message: 'Passwords do not match' });
  }
  
  if (!validatePassword(password)) {
    return res.status(400).json({ message: 'Password must be at least 8 characters long and contain both letters and numbers' });
  }
  
  try {
    const user = await prisma.users.findUnique({ where: { email } });
    if (!user) {
      return res.status(404).json({ message: 'Email not found' });
    }
    
    const hashedPassword = await bcrypt.hash(password, 12);
    const updatedUser = await prisma.users.update({
      where: { email },
      data: { password: hashedPassword }
    });
    
    res.json({ 
      message: 'Password reset successful',
      user: {
        id: Number(updatedUser.id), // Convert BigInt to Number
        email: updatedUser.email,
        username: updatedUser.username
      }
    });
  } catch (err) {
    console.error('Reset password error:', err);
    res.status(500).json({ 
      message: 'Server error', 
      error: process.env.NODE_ENV === 'development' ? err.message : 'Internal server error' 
    });
  }
};

// Th√™m alias cho register
exports.createUser = exports.register;

exports.onboarding = async (req, res) => {
  try {
    const { email, gender, topics } = req.body; // topics = [1,2,3]

    // 1. Validate input
    if (!email || !gender || !topics || !Array.isArray(topics)) {
      return res.status(400).json({ 
        success: false, 
        message: "Email, gender v√† topics l√† b·∫Øt bu·ªôc" 
      });
    }

    // 2. T√¨m user theo email
    const user = await prisma.users.findUnique({ where: { email } });
    if (!user) {
      return res.status(404).json({ 
        success: false, 
        message: "Kh√¥ng t√¨m th·∫•y user" 
      });
    }

    // 3. Th√™m d·ªØ li·ªáu v√†o b·∫£ng user_topics
    await prisma.user_topics.createMany({
      data: topics.map(topicId => ({
        user_id: user.id,
        topic_id: topicId
      })),
      skipDuplicates: true // tr√°nh l·ªói tr√πng l·∫∑p
    });

    // 4. Update user: ch·ªâ c·∫≠p nh·∫≠t gender + onboarded
    const updatedUser = await prisma.users.update({
      where: { email },
      data: {
        gender,
        onboarded: true
      },
      include: {
        userTopics: {
          include: { topic: true }
        }
      }
    });

    // 5. Tr·∫£ v·ªÅ k·∫øt qu·∫£
    res.status(200).json({
      success: true,
      message: "Onboarding completed successfully",
      user: {
        id: updatedUser.id,
        email: updatedUser.email,
        gender: updatedUser.gender,
        onboarded: updatedUser.onboarded,
        topics: updatedUser.userTopics.map(ut => ut.topic)
      }
    });

  } catch (error) {
    console.error("Onboarding error:", error);
    res.status(500).json({ 
      success: false, 
      message: "L·ªói server trong qu√° tr√¨nh onboarding" 
    });
  }
};


// Th√™m route test g·ª≠i mail
exports.testSendMail = async(req, res) => {
  try {
    await sendMail({
      to: req.body.to || process.env.EMAIL_USER,
      subject: 'Test Nodemailer',
      text: 'ƒê√¢y l√† email test t·ª´ Social Media App!',
      html: '<b>ƒê√¢y l√† email test t·ª´ Social Media App!</b>'
    });
    res.status(200).json({ message: 'ƒê√£ g·ª≠i email th√†nh c√¥ng!' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
}
exports.getUserFeed = async (req, res) => {
  try {
    const userId = parseInt(req.params.id);

    // 1. L·∫•y topics user ƒë√£ ch·ªçn
    const userTopics = await prisma.user_topics.findMany({
      where: { user_id: userId },
      include: { topic: true },
    });

    // 2. L·∫•y posts c√≥ tag tr√πng topic
    const posts = await prisma.posts.findMany({
      where: {
        post_topics: {
          some: {
            topic_id: { in: userTopics.map((ut) => ut.topic_id) },
          },
        },
      },
      include: {
        users: true,
        post_topics: { include: { topics: true } },
      },
      orderBy: { createdAt: "desc" },
      take: 50,
    });

    res.json(posts);
  } catch (err) {
    console.error("Error fetching feed:", err);
    res.status(500).json({ error: "Failed to fetch feed" });
  }
};

